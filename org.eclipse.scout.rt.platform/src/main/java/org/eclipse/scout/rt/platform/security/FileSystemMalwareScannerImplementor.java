/*
 * Copyright (c) 2010, 2023 BSI Business Systems Integration AG
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.scout.rt.platform.security;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;

import org.eclipse.scout.rt.platform.config.CONFIG;
import org.eclipse.scout.rt.platform.config.PlatformConfigProperties.MalwareScannerDelayProperty;
import org.eclipse.scout.rt.platform.config.PlatformConfigProperties.MalwareScannerPathProperty;
import org.eclipse.scout.rt.platform.resource.BinaryResource;
import org.eclipse.scout.rt.platform.resource.BinaryResources;
import org.eclipse.scout.rt.platform.util.IOUtility;
import org.eclipse.scout.rt.platform.util.SleepUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This {@link IMalwareScannerImplementor} implementation copies the resource to be scanned into a special folder
 * (specified by {@link MalwareScannerPathProperty}), reads it back in and verifies the equality of the two streams.
 * This default scanner assumes that an appropriate malware scanner is in place and scans a special folder using a
 * realtime filesystem scan strategy. Malware should therefore immediately be removed or blocked by the malware
 * implementation.
 */
public class FileSystemMalwareScannerImplementor implements IMalwareScannerImplementor {

  private static final Logger LOG = LoggerFactory.getLogger(FileSystemMalwareScannerImplementor.class);

  @Override
  public void scan(BinaryResource res) {
    if (res == null) {
      return;
    }
    File directory = IOUtility.toFile(CONFIG.getPropertyValue(MalwareScannerPathProperty.class));
    if (directory != null && (!directory.exists() || !directory.isDirectory())) {
      LOG.error("Unable to check for malware because configured target path '{}' is invalid.", directory);
      throw new UnsafeResourceException("Resource '{}' may be unsafe (unable to check)", res.getFilename());
    }
    File f = null;
    try {
      byte[] expected = res.getContent();
      if (expected != null && expected.length > 0) {
        f = IOUtility.createTempFile("malware-scan", ".tmp", directory, expected);
        int delay = CONFIG.getPropertyValue(MalwareScannerDelayProperty.class);
        SleepUtil.sleepElseThrow(delay, TimeUnit.MILLISECONDS);
        byte[] actual;
        try (FileInputStream in = new FileInputStream(f)) {
          actual = IOUtility.readBytes(in, expected.length);
        }
        if (!Arrays.equals(expected, actual)) {
          LOG.info("detected unsafe resource '{}'", res.getFilename());
          throwUnsafeResource(res);
        }
      }
    }
    catch (UnsafeResourceException e) {
      LOG.info(e.getMessage());
      throw e;
    }
    catch (Exception e) {//NOSONAR each on-site malware scanner may behave differently, e.g. StreamCorruptedException, FileNotFoundException, ...
      if (LOG.isDebugEnabled()) {
        LOG.debug("Exception while checking for malware", e);
      }
      throwUnsafeResource(res);
    }
    finally {
      IOUtility.deleteFile(f);
    }
  }

  @Override
  public void scan(String filename, InputStream input) {
    if (input == null) {
      return;
    }
    BinaryResource res = BinaryResources.create()
        .withFilename(filename)
        .withContent(IOUtility.readBytes(input)).build();
    scan(res);
  }

  protected void throwUnsafeResource(BinaryResource res) {
    LOG.info("detected unsafe resource '{}'", res.getFilename());
    throw new UnsafeResourceException("Resource '{}' is not safe", res.getFilename());
  }
}
