/*
 * Copyright (c) 2010, 2023 BSI Business Systems Integration AG
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.scout.rt.platform.security;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;

import org.eclipse.scout.rt.platform.config.CONFIG;
import org.eclipse.scout.rt.platform.config.PlatformConfigProperties.MalwareScannerDelayProperty;
import org.eclipse.scout.rt.platform.config.PlatformConfigProperties.MalwareScannerPathProperty;
import org.eclipse.scout.rt.platform.resource.BinaryResource;
import org.eclipse.scout.rt.platform.util.FileUtility;
import org.eclipse.scout.rt.platform.util.IOUtility;
import org.eclipse.scout.rt.platform.util.SleepUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This {@link IMalwareScannerImplementor} implementation copies the resource to be scanned into a special folder
 * (specified by {@link MalwareScannerPathProperty}), reads it back in and verifies the equality of the two streams.
 * This default scanner assumes that an appropriate malware scanner is in place and scans a special folder using a
 * realtime filesystem scan strategy. Malware should therefore immediately be removed or blocked by the malware
 * implementation.
 */
public class FileSystemMalwareScannerImplementor implements IMalwareScannerImplementor {

  private static final Logger LOG = LoggerFactory.getLogger(FileSystemMalwareScannerImplementor.class);

  @Override
  public void scan(BinaryResource res) {
    if (res == null) {
      return;
    }
    File directory = IOUtility.toFile(CONFIG.getPropertyValue(MalwareScannerPathProperty.class));
    if (directory != null && (!directory.exists() || !directory.isDirectory())) {
      LOG.error("Unable to check for malware because configured target path '{}' is invalid.", directory);
      throw new UnsafeResourceException("Resource '{}' may be unsafe (unable to check)", res.getFilename());
    }
    File f = null;
    try {
      byte[] expected = res.getContent();
      if (expected != null && expected.length > 0) {
        f = IOUtility.createTempFile("malware-scan", ".tmp", directory, expected);
        int delay = CONFIG.getPropertyValue(MalwareScannerDelayProperty.class);
        SleepUtil.sleepElseThrow(delay, TimeUnit.MILLISECONDS);
        byte[] actual;
        try (FileInputStream in = new FileInputStream(f)) {
          actual = IOUtility.readBytes(in, expected.length);
        }
        if (!Arrays.equals(expected, actual)) {
          LOG.info("detected unsafe resource '{}'", res.getFilename());
          throwUnsafeResource(res);
        }
      }
    }
    catch (UnsafeResourceException e) {
      LOG.info(e.getMessage());
      throw e;
    }
    catch (Exception e) {//NOSONAR each on-site malware scanner may behave differently, e.g. StreamCorruptedException, FileNotFoundException, ...
      if (LOG.isDebugEnabled()) {
        LOG.debug("Exception while checking for malware", e);
      }
      throwUnsafeResource(res);
    }
    finally {
      IOUtility.deleteFile(f);
    }
  }

  @Override
  public void scan(Path path) {
    if (path == null) {
      return;
    }
    if (Files.isDirectory(path)) {
      throw new UnsafeResourceException("Scanning directory not supported.");
    }
    File directory = IOUtility.toFile(CONFIG.getPropertyValue(MalwareScannerPathProperty.class));
    if (directory != null && (!directory.exists() || !directory.isDirectory())) {
      LOG.error("Unable to check for malware because configured target path '{}' is invalid.", directory);
      throw new UnsafeResourceException("Resource '{}' may be unsafe (unable to check)", path.getFileName());
    }
    File tmpFile = null;
    try {
      tmpFile = File.createTempFile("malware-scan", ".tmp", directory);
      tmpFile.deleteOnExit();
      FileUtility.copyFile(path.toFile(), tmpFile);
      int delay = CONFIG.getPropertyValue(MalwareScannerDelayProperty.class);
      SleepUtil.sleepElseThrow(delay, TimeUnit.MILLISECONDS);
      if (compareFiles(path, tmpFile.toPath()) != -1) {
        LOG.info("detected unsafe resource '{}'", path);
        throwUnsafeResource(path);
      }
    }
    catch (UnsafeResourceException e) {
      LOG.info(e.getMessage());
      throw e;
    }
    catch (Exception e) {//NOSONAR each on-site malware scanner may behave differently, e.g. StreamCorruptedException, FileNotFoundException, ...
      if (LOG.isDebugEnabled()) {
        LOG.debug("Exception while checking for malware", e);
      }
      throwUnsafeResource(path);
    }
    finally {
      IOUtility.deleteFile(tmpFile);
    }
  }

  protected long compareFiles(Path path1, Path path2) throws IOException {
    try (BufferedInputStream fis1 = new BufferedInputStream(new FileInputStream(path1.toFile()));
        BufferedInputStream fis2 = new BufferedInputStream(new FileInputStream(path2.toFile()))) {

      int ch = 0;
      long pos = 1;
      while ((ch = fis1.read()) != -1) {
        if (ch != fis2.read()) {
          return pos;
        }
        pos++;
      }
      if (fis2.read() == -1) {
        return -1;
      }
      else {
        return pos;
      }
    }
  }

  protected void throwUnsafeResource(BinaryResource res) {
    LOG.info("detected unsafe resource '{}'", res.getFilename());
    throw new UnsafeResourceException("Resource '{}' is not safe", res.getFilename());
  }

  protected void throwUnsafeResource(Path path) {
    LOG.info("detected unsafe resource '{}'", path.getFileName());
    throw new UnsafeResourceException("Resource '{}' is not safe", path.getFileName());
  }
}
